{"Name":"SQLite.NET","Id":221,"Alias":"sqlite-net","Description":"SQLite.NET is an open source, minimal library to allow .NET and Mono applications to store data in [SQLite 3 databases](http://www.sqlite.org). SQLite.NET was designed as a quick and convenient database layer. Its design follows from these *goals*:\r\n\r\n* Very easy to integrate with existing projects and with Xamarin projects.\r\n  \r\n* Thin wrapper over SQLite and should be fast and efficient. (The library should not be the performance bottleneck of your queries.)\r\n  \r\n* Very simple methods for executing CRUD operations and queries safely (using parameters) and for retrieving the results of those query in a strongly typed fashion.\r\n  \r\n* Works with your data model without forcing you to change your classes. (Contains a small reflection-driven ORM layer.)\r\n\r\n*Non-goals* include:\r\n\r\n* Not an ADO.NET implementation. This is not a full SQLite driver. If you need that, use [Mono.Data.SQLite](http://www.mono-project.com/SQLite) or [csharp-sqlite](http://code.google.com/p/csharp-sqlite/).\r\n\r\n## Example\r\n\r\n```csharp\r\nusing SQLite;\r\n// ...\r\n\r\npublic class Note\r\n{\r\n\t[PrimaryKey, AutoIncrement]\r\n\tpublic int Id { get; set; }\r\n\tpublic string Message { get; set; }\r\n}\r\n\r\n// Create our connection\r\nstring folder = Environment.GetFolderPath (Environment.SpecialFolder.Personal);\r\nvar db = new SQLiteConnection (System.IO.Path.Combine (folder, \"notes.db\"));\r\ndb.CreateTable\u003cNote\u003e();\r\n\r\n// Insert note into the database\r\nvar note = new Note { Message = \"Test Note\" };\r\ndb.Insert (note);\r\n\r\n// Show the automatically set ID and message.\r\nConsole.WriteLine (\"{0}: {1}\", note.Id, note.Message);\r\n```","Version":"1.0.1","Summary":"Simple, powerful, cross-platform SQLite client and ORM","QuickStart":"Please consult the Wiki for, ahem, [complete documentation](https://github.com/praeclarum/sqlite-net/wiki).\r\n\r\nThe library contains simple attributes that you can use to control the construction of tables. In a simple stock program, you might use:\r\n\r\n```csharp\r\nusing  SQLite;\r\n// ...\r\n\r\npublic class Stock\r\n{\r\n\t[PrimaryKey, AutoIncrement]\r\n\tpublic int Id { get; set; }\r\n\t[MaxLength(8)]\r\n\tpublic string Symbol { get; set; }\r\n}\r\n\r\npublic class Valuation\r\n{\r\n\t[PrimaryKey, AutoIncrement]\r\n\tpublic int Id { get; set; }\r\n\t[Indexed]\r\n\tpublic int StockId { get; set; }\r\n\tpublic DateTime Time { get; set; }\r\n\tpublic decimal Price { get; set; }\r\n}\r\n```\r\n\r\nOnce you\u0027ve defined the objects in your model you have a choice of APIs. You can use the \"synchronous API\" where calls\r\nblock one at a time, or you can use the \"asynchronous API\" where calls do not block. You may care to use the asynchronous\r\nAPI for mobile applications in order to increase reponsiveness.\r\n\r\nBoth APIs are explained in the two sections below.\r\n\r\n## Synchronous API\r\n\r\nOnce you have defined your entity, you can automatically generate tables in your database by calling `CreateTable`:\r\n\r\n```csharp\r\nstring folder = Environment.GetFolderPath (Environment.SpecialFolder.Personal);\r\nvar conn = new SQLiteConnection (System.IO.Path.Combine (folder, \"stocks.db\"));\r\nconn.CreateTable\u003cStock\u003e();\r\nconn.CreateTable\u003cValuation\u003e();\r\n```\r\n\r\nYou can insert rows in the database using `Insert`. If the table contains an auto-incremented primary key, then the value for that key will be available to you after the insert:\r\n\r\n```csharp\r\npublic static void AddStock (SQLiteConnection db, string symbol) {\r\n\tvar s = new Stock { Symbol = symbol };\r\n\tdb.Insert (s);\r\n\tConsole.WriteLine (\"{0} == {1}\", s.Symbol, s.Id);\r\n}\r\n```\r\n\r\nSimilar methods exist for `Update` and `Delete`.\r\n\r\nThe most straightforward way to query for data is using the `Table` method. This can take predicates for constraining via WHERE clauses and/or adding ORDER BY clauses:\r\n\r\n```csharp\r\nvar query = conn.Table\u003cStock\u003e().Where (v =\u003e v.Symbol.StartsWith(\"A\"));\r\n\r\nforeach (var stock in query)\r\n\tConsole.WriteLine (\"Stock: \" + stock.Symbol);\r\n```\r\n\r\nYou can also query the database at a low-level using the `Query` method:\r\n\r\n```csharp\r\npublic static IEnumerable\u003cValuation\u003e QueryValuations (SQLiteConnection db, Stock stock)\r\n{\r\n\treturn db.Query\u003cValuation\u003e (\"select * from Valuation where StockId = ?\", stock.Id);\r\n}\r\n```\r\n\r\nThe generic parameter to the `Query` method specifies the type of object to create for each row. It can be one of your table classes, or any other class whose public properties match the column returned by the query. For instance, we could rewrite the above query as:\r\n\r\n```csharp\r\npublic class Val {\r\n\tpublic decimal Money { get; set; }\r\n\tpublic DateTime Date { get; set; }\r\n}\r\n\r\npublic static IEnumerable\u003cVal\u003e QueryVals (SQLiteConnection db, Stock stock)\r\n{\r\n\treturn db.Query\u003cVal\u003e (\"select \u0027Price\u0027 as \u0027Money\u0027, \u0027Time\u0027 as \u0027Date\u0027 from Valuation where StockId = ?\", stock.Id);\r\n}\r\n```\r\n\r\nYou can perform low-level updates of the database using the `Execute` method.\r\n\r\n## Asynchronous API\r\n\r\nTo use the asynchronous API, you\u0027ll create a `SQLiteAsyncConnection` instead of `SQLiteConnection`. `SQLiteAsyncConnection` exposes asynchronous versions of the database APIs providing you with `Task` to perform continuations on.\r\n\r\nOnce you have defined your entity, you can automatically generate tables by calling `CreateTableAsync`:\r\n\r\n```csharp\r\nstring folder = Environment.GetFolderPath (Environment.SpecialFolder.Personal);\r\nvar conn = new SQLiteAsyncConnection (System.IO.Path.Combine (folder, \"stocks.db\"));\r\nconn.CreateTableAsync\u003cStock\u003e().ContinueWith (t =\u003e {\r\n\tConsole.WriteLine (\"Table created!\");\r\n});\r\n```\r\n\r\nYou can insert rows in the database using `Insert`. If the table contains an auto-incremented primary key, then the value for that key will be available to you after the insert:\r\n\r\n```csharp\r\nStock stock = new Stock { Symbol = \"AAPL\" };\r\n\r\nconn.InsertAsync (stock).ContinueWith (t =\u003e {\r\n\tConsole.WriteLine (\"New customer ID: {0}\", stock.Id);\r\n});\r\n```\r\n\r\nSimilar methods exist for `UpdateAsync` and `DeleteAsync`.\r\n\r\nQuerying for data is most straightforwardly done using the `Table` method. This will return an `AsyncTableQuery` instance back, whereupon\r\nyou can add predictates for constraining via WHERE clauses and/or adding ORDER BY. The database is not physically touched until one of the special \r\nretrieval methods - `ToListAsync`, `FirstAsync`, or `FirstOrDefaultAsync` - is called.\r\n\r\n```csharp\r\nvar query = conn.Table\u003cStock\u003e().Where (v =\u003e v.Symbol.StartsWith (\"A\"));\r\n\r\nquery.ToListAsync().ContinueWith (t =\u003e {\r\n\tforeach (var stock in t.Result)\r\n\t\tConsole.WriteLine (\"Stock: \" + stock.Symbol);\r\n});\r\n```\r\n\r\nThere are a number of low-level methods available. You can also query the database directly via the `QueryAsync` method. Over and above the change \r\noperations provided by `InsertAsync` etc you can issue `ExecuteAsync` methods to change sets of data directly within the database.\r\n\r\nAnother helpful method is `ExecuteScalarAsync`. This allows you to return a scalar value from the database easily:\r\n\r\n```csharp\r\nconn.ExecuteScalarAsync\u003cint\u003e (\"select count(*) from Stock\", null).ContinueWith (t =\u003e {\r\n\tConsole.WriteLine (string.Format(\"Found \u0027{0}\u0027 stock items.\", t.Result));\r\n});\r\n```\r\n","Hash":"81420f29c49653d682c836b544093469","TargetPlatforms":["ios","android"],"TrialHash":null}