<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
    <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
    <title>Xamarin University</title>
    <script src="https://google-code-prettify.googlecode.com/svn/loader/run_prettify.js"></script>
    <link rel="stylesheet" type="text/css" href="./res/styles/normalize.css">
    <link rel="stylesheet" type="text/css" href="./res/styles/styles.css">
    <script src="./res/js/script.js"></script>
</head>

<body>
    <header>Advanced Cross Platform Mobile Development</header>

    <section id="main">


        <!-- Exercise #1 -->        
        <h1 class="spacing-top" id="part3">Exercise 1: Use the Factory Pattern to create a Dependency
</h1>
        <h2>Knowledge Needed</h2>
        <div class="wsitem">
            <b>Working with Abstractions</b><br />
            <p>As functionality is added to our mobile application, the shared code will need access to specific services that are different on a platform-by-platform basis, or might only be available to certain platforms. In these cases, we can use variations of the <a href="http://www.dofactory.com/Patterns/PatternBridge.aspx">Bridge Pattern</a> to create abstractions so the implementation can change for each platform.</p>
            <p>In order to find these abstractions, we will use some variation of the <a href="http://msdn.microsoft.com/en-us/library/ff921087.aspx">Inversion of Control (IoC)</a> principle - this is where the implemention is not known until the application executes. One of the most common approaches to this is to use a variation of the <a href="http://www.oodesign.com/factory-pattern.html">Factory Pattern</a>. This allows our cross-platform code to depend on the abstraction and go through an intermediary to create the implementation. That implementation could be a separate class (classic defintion of the pattern), or a delegate / event wired up in the platform-specific code.</p>

            <h2>Exploring On Your Own</h2>
        <div class="wslist">
            <a href="http://msdn.microsoft.com/en-us/library/ee817667.aspx">Exploring the Factory Pattern (MSDN)</a>
        </div>
        </div>

        <!-- Exercise #2 -->        
        <h1 class="spacing-top" id="part3">Exercise 2: Build a Service Locator</h1>
        <h2>Knowledge Needed</h2>
        <div class="wsitem">
            Another common approach the Inversion of Control principle is the <a href="http://en.wikipedia.org/wiki/Service_locator_pattern">Service Locator</a>. The Service Locator pattern provides a global registry for the required dependencies. As with the Factory pattern, the client depends on an abstraction, but now looks up the implementation type at runtime through the Service Locator class.</p>
        </div>

        <h2>Exploring On Your Own</h2>
        <div class="wslist">
            <a href="https://commonservicelocator.codeplex.com/">Common Service Locator (Microsoft P&amp;P)</a>
        </div>
        <!-- Exercise #3 -->        
        <h1 class="spacing-top" id="part4">Exercise 3: Using Dependency Injection</h1>
        <h2>Knowledge Needed</h2>
        <div class="wsitem">
            <b>Dependency Injection</b><br />
            <p>A final approach to managing dependencies is to provide them through constructors, properties or methods. This approach is referred to as <a href="http://en.wikipedia.org/wiki/Dependency_injection">Dependency Injection</a> and can be done manually, or more commonly, through a container which creates the type and supplies the dependency as part of the creation.</p>
        </div>

        <h2>Exploring On Your Own</h2>
        <div class="wslist">
            <a href="http://martinfowler.com/articles/injection.html">Inversion of Control Containers and the Dependency Injection pattern (Martin Fowler)</a>
            <a href="http://msdn.microsoft.com/en-us/magazine/cc163739.aspx">Dependency Injection (MSDN Magazine)</a>
        </div>

        <h2>Dependency Injection Containers</h2>
        <p>Here are some popular implementaions of DI containers you can use. Most of these are open source, or public source projects. Keep in mind that many MVVM libraries have built-in DI containers.</p>
        <div class="wslist">
            <a href="https://github.com/grumpydev/TinyIoC">Tiny.IoC</a>
            <a href="http://www.ninject.org/">Ninject</a>
            <a href="https://ioc.codeplex.com/">OpenNETCF.IoC</a>
            <a href="http://www.castleproject.org/">Castle Windsor</a>
            <a href="http://msdn.microsoft.com/en-us/library/ff647202.aspx">Unity (Microsoft P&amp;P)</a>
            <a href="http://springframework.net/">Spring.NET</a>
            <a href="http://docs.structuremap.net/">Structure Map</a>
            <a href="https://github.com/autofac/Autofac">AutoFac</a>
        </div>

    </section>
    <footer>Copyright (C) 2014 Xamarin</footer>

</body>

</html>
